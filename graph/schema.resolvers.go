package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"smail/graph/model"
	"sort"
)

// ToggleStarred is the resolver for the toggleStarred field.
func (r *mutationResolver) ToggleStarred(ctx context.Context, messageID string) (*model.Message, error) {
	panic(fmt.Errorf("not implemented: ToggleStarred - toggleStarred"))
}

// Messages is the resolver for the messages field.
func (r *queryResolver) Messages(ctx context.Context, pagination *model.PaginationInput) ([]*model.Message, error) {
	// Check if the messages are in the cache
	limit := IntValueOrDefault(pagination.Limit, 10)
	offset := IntValueOrDefault(pagination.Offset, 0)

	cacheKey := fmt.Sprintf("messages:%v:%v", limit, offset)
	if cachedMessages, err := r.Cache.GetMessages(ctx, cacheKey); err == nil {
		return cachedMessages, nil
	}

	// If not, fetch from the database
	messages, err := r.DB.GetMessages(ctx, pagination)
	if err != nil {
		return nil, err
	}

	if len(messages) < *pagination.Limit {
		// Cache the messages
		r.Cache.SetMessages(ctx, cacheKey, messages)
	}

	// Try to fetch from the gmail API
	gmailMessages, err := r.Gmail.FetchMessages(ctx, pagination.Limit, pagination.Offset)
	if err != nil {
		return nil, err
	}

	// Merge the messages
	messages = append(messages, gmailMessages...)

	// Cache the merged messages
	r.Cache.SetMessages(ctx, cacheKey, messages)

	// Sort the messages by timestamp
	sort.Slice(messages, func(i, j int) bool {
		return messages[i].Timestamp > messages[j].Timestamp
	})

	return messages, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
